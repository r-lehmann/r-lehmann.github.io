"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CampaignConfiguration = void 0;
var _tsRes = require("ts-res");
var _constants = require("./constants");
var _eventSource = require("../eventSource");
var _types = require("../types");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class CampaignConfiguration {
  constructor({
    settings,
    storage,
    requester,
    externalClientConfiguration,
    targetingCleanupInterval
  }) {
    _defineProperty(this, "configurationUpdateCallback", void 0);
    _defineProperty(this, "updateConfigurationIntervalId", null);
    _defineProperty(this, "targetingDataIntervalId", null);
    _defineProperty(this, "unsentTargetingData", {});
    _defineProperty(this, "targetingData", _constants.DEFAULT_CAMPAIGN_CONFIGURATION.targetingData);
    _defineProperty(this, "configurationData", _constants.DEFAULT_CAMPAIGN_CONFIGURATION.configurationData);
    _defineProperty(this, "settings", void 0);
    _defineProperty(this, "lastUpdate", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "requester", void 0);
    _defineProperty(this, "eventSource", void 0);
    _defineProperty(this, "externalClientConfiguration", void 0);
    this.requester = requester;
    this.settings = settings;
    this.lastUpdate = new Date();
    this.storage = storage;
    this.readStorageData();
    this.externalClientConfiguration = externalClientConfiguration;
    if (targetingCleanupInterval) {
      const cleanupIntervalMinutes = targetingCleanupInterval < 0 ? 1 : targetingCleanupInterval;

      // --- Note ---
      // We can not make delayed code execution recoverable, as it might lead
      // to targeting data storage size overflow
      try {
        this.targetingDataIntervalId = setInterval(() => this.cleanupOutdatedTargetingData.call(this, this.targetingData), cleanupIntervalMinutes * _types.Milliseconds.Minute);
      } catch (err) {
        if (this.targetingDataIntervalId) {
          clearInterval(this.targetingDataIntervalId);
        }
        throw err;
      }
    }
  }
  async initialize(externalEventSource) {
    const shouldUpdate = this.checkShouldUpdate();

    // --- Initial data fetch ---
    if (shouldUpdate) {
      const updateResult = await this.updateClientConfiguration();
      if (!updateResult.ok) {
        return updateResult;
      }
    }

    // --- Note ---
    // Interval is cleaned up in case real time update
    // was activated while initialized client already exists
    if (this.configurationData.configuration.realTimeUpdate && !this.externalClientConfiguration) {
      if (this.updateConfigurationIntervalId) {
        clearInterval(this.updateConfigurationIntervalId);
      }
      this.eventSource = new _eventSource.ExternalEventSource(this.settings.siteCode, externalEventSource);
      const updateEventCallback = _timeStamp => {
        this.updateClientConfiguration();
        if (this.configurationUpdateCallback) {
          this.configurationUpdateCallback();
        }
      };
      this.eventSource.open(updateEventCallback);
    } else {
      // --- Note ---
      // Event Source is cleaned up in case real time update
      // was disabled while initialized client already exists
      if (this.eventSource) {
        this.eventSource.close();
      }
      if (this.updateConfigurationIntervalId) {
        clearInterval(this.updateConfigurationIntervalId);
      }

      // --- Note ---
      // Same as targeting data interval we don't want to make failed configuration
      // retrieval recoverable
      try {
        this.updateConfigurationIntervalId = setInterval(this.updateClientConfiguration.bind(this), this.settings.updateInterval);
      } catch (err) {
        if (this.updateConfigurationIntervalId) {
          clearInterval(this.updateConfigurationIntervalId);
        }
        throw err;
      }
    }
    return (0, _tsRes.Ok)();
  }
  addTargetingData(visitorCode, ...data) {
    if (!(visitorCode in this.targetingData)) {
      this.targetingData[visitorCode] = [];
    }
    data.forEach(dataItem => {
      // --- Note ---
      // Previous check excludes the failure possibility
      this.targetingData[visitorCode].push({
        data: dataItem.data,
        lastActivityTime: Date.now()
      });
    });

    // --- Note ---
    // `targetingData` should not refresh `lastUpdate` time
    const result = this.updateStorageData(this.lastUpdate);
    if (result.ok) {
      data.forEach(dataItem => {
        if (!this.unsentTargetingData[visitorCode]) {
          this.unsentTargetingData[visitorCode] = [];
        }
        this.unsentTargetingData[visitorCode].push(dataItem);
      });
    }
    return result;
  }
  getUnsentData(visitorCode) {
    const unsentDataItem = this.unsentTargetingData[visitorCode];
    if (!unsentDataItem) {
      return [];
    }
    return unsentDataItem;
  }
  clearUnsentData(visitorCode) {
    this.unsentTargetingData[visitorCode] = [];
  }
  onConfigurationUpdate(callback) {
    this.configurationUpdateCallback = callback;
  }
  get storedTargetingData() {
    return this.targetingData;
  }
  get experiments() {
    return this.configurationData.experiments;
  }
  get featureFlags() {
    return this.configurationData.featureFlags;
  }
  get configuration() {
    return this.configurationData.configuration;
  }
  checkShouldUpdate() {
    const {
      featureFlags,
      experiments,
      configuration
    } = this.configurationData;
    const {
      updateInterval
    } = this.settings;
    if (!featureFlags.length && !experiments.length) {
      return true;
    }
    if (configuration.realTimeUpdate) {
      return true;
    }
    const lastUpdateTime = this.lastUpdate.getTime();
    const updateWindowEdge = Date.now() - updateInterval;
    return lastUpdateTime < updateWindowEdge;
  }
  cleanupOutdatedTargetingData(data) {
    const currentTime = Date.now();
    const resultTargetingData = _objectSpread({}, data);
    for (const [key, value] of Object.entries(resultTargetingData)) {
      if (value) {
        const resultValue = value.filter(item => {
          const isDataExpired = item.lastActivityTime + _constants.SESSION_DURATION < currentTime;
          return isDataExpired;
        });
        resultTargetingData[key] = resultValue;
      } else {
        resultTargetingData[key] = [];
      }
    }
    this.targetingData = resultTargetingData;
    // --- Note ---
    // `targetingData` should not refresh `lastUpdate` time
    this.updateStorageData(this.lastUpdate).throw();
  }
  readStorageData() {
    const result = this.storage.read();
    if (result.ok) {
      const {
        kameleoonTargetingData,
        kameleoonConfiguration,
        lastUpdate
      } = result.data;
      this.configurationData = kameleoonConfiguration;
      this.targetingData = kameleoonTargetingData;
      this.lastUpdate = new Date(Date.parse(lastUpdate));
    }
  }
  async updateClientConfiguration(timeStamp) {
    // --- Note ---
    // if `externalClientConfiguration` is passed, fetching is disabled and passed config is used instead
    if (this.externalClientConfiguration) {
      // --- Note ---
      // `featureFlags` field is omitted (v1)
      // instead `featureFlagConfigurations` is used (v2)
      const {
        configuration,
        experiments,
        featureFlagConfigurations
      } = this.externalClientConfiguration;
      this.configurationData = {
        configuration,
        experiments,
        featureFlags: featureFlagConfigurations
      };
    } else {
      const clientConfigurationResult = await this.requester.getClientConfiguration(timeStamp);
      if (!clientConfigurationResult.ok) {
        return clientConfigurationResult;
      }

      // --- Note ---
      // `featureFlags` field is omitted (v1)
      // instead `featureFlagConfigurations` is used (v2)
      const {
        configuration,
        experiments,
        featureFlagConfigurations
      } = clientConfigurationResult.data;
      this.configurationData = {
        configuration,
        experiments,
        featureFlags: featureFlagConfigurations
      };
    }
    const result = this.updateStorageData(new Date());
    if (!result.ok) {
      return result;
    }
    return (0, _tsRes.Ok)(true);
  }
  updateStorageData(lastUpdate) {
    const data = {
      kameleoonTargetingData: this.targetingData,
      kameleoonConfiguration: this.configurationData,
      lastUpdate: lastUpdate.toString()
    };
    return this.storage.write(data);
  }
}
exports.CampaignConfiguration = CampaignConfiguration;
//# sourceMappingURL=campaignConfiguration.js.map