"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TargetExperimentCondition = void 0;
var _tsRes = require("ts-res");
var _types = require("../types");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class TargetExperimentCondition {
  constructor({
    variation,
    experiment,
    isInclude,
    variationMatchType
  }) {
    _defineProperty(this, "inverseResult", void 0);
    _defineProperty(this, "experimentId", void 0);
    _defineProperty(this, "variationId", void 0);
    _defineProperty(this, "matchType", void 0);
    this.inverseResult = !(isInclude ?? true);
    this.experimentId = experiment;
    this.variationId = variation;
    this.matchType = variationMatchType;
  }
  evaluate({
    variationData
  }) {
    if (!this.experimentId) {
      return (0, _tsRes.Ok)(false);
    }
    if (this.matchType === _types.MatchTypeVariation.EXACT && !this.variationId) {
      (0, _tsRes.Ok)(false);
    }
    const result = this.checkCondition({
      variationId: this.variationId,
      experimentId: this.experimentId,
      variationData
    });
    return (0, _tsRes.Ok)(this.inverseResult ? !result : result);
  }
  checkCondition({
    variationId,
    experimentId,
    variationData
  }) {
    const experimentIdString = String(experimentId);
    const variation = variationData[experimentIdString];
    switch (this.matchType) {
      case _types.MatchTypeVariation.EXACT:
        {
          return variation?.variationId === variationId;
        }
      case _types.MatchTypeVariation.ANY:
        return Boolean(variation);
      default:
        return false;
    }
  }
}
exports.TargetExperimentCondition = TargetExperimentCondition;
//# sourceMappingURL=targetExperimentCondition.js.map