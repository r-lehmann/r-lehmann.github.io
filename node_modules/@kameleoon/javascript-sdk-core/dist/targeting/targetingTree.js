"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TargetingTree = void 0;
var _tsRes = require("ts-res");
var _targetingNode = require("./targetingNode");
var _types = require("./types");
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class TargetingTree {
  constructor(segment) {
    _defineProperty(this, "tree", void 0);
    _defineProperty(this, "error", null);
    const {
      conditions,
      operators
    } = this.flattenSegment(segment);
    const nodes = conditions.map(condition => new _targetingNode.TargetingNode(condition));

    // --- Note ---
    // - Targeting tree is built bottom-up, it's the only way to both get the consistent logic
    // (grouping nested conditions) and have human readable tree representation.
    // - Here is an example of how tree is built (we use strict complete binary tree)
    // Let's say we have such a condition `value < 10 || value > 20 && value < 30`
    // Code-wise it looks as follows (this is not real code, real tree is more complicated and can have more
    // levels of deeply nested conditions):
    //
    // `const operators = [Operator.Or, Operator.And]`
    // `const conditions = [
    //     {type: Condition.Less, value: 10},
    //     {type: Condition.Greater, value: 20},
    //     {type: Condition.Less, value: 30},
    // ]`
    //
    // After the first iteration we have node like this:
    //    AND
    //   /   \
    //  <30  >20
    //
    // After the second iteration tree looks as follows:
    //         OR
    //        /  \
    //    AND    <10
    //   /   \
    //  <30  >20
    // As you can see Leaf Nodes contain conditions and Non-Leaf Nodes contain logical operators
    for (const operator of operators) {
      const left = nodes.shift();
      const right = nodes.shift();
      nodes.unshift(new _targetingNode.TargetingNode(operator, left, right));
    }

    // --- Note ---
    // It's guaranteed that only one root node will remain after iterations
    // (as soon as the backend `operators-conditions` relation doesn't change)
    this.tree = nodes[0];
  }
  evaluate(data) {
    const result = this.evaluateNode(this.tree, data);
    if (this.error) {
      return (0, _tsRes.Err)(this.error);
    }
    return (0, _tsRes.Ok)(result);
  }
  evaluateNode(node, data) {
    if (this.isLeafNode(node)) {
      if (node.error) {
        // --- Note ---
        // Non-existing condition should not break targeting tree
        // instead it should be treated as `false` condition
        return false;
      }
      const result = node.value.evaluate(data);
      if (!result.ok) {
        this.error = result.error;
        return false;
      }
      return result.data;
    }
    if (this.isNonLeafNode(node)) {
      switch (node.value) {
        case _types.Operator.And:
          {
            return this.evaluateNode(node.left, data) && this.evaluateNode(node.right, data);
          }
        case _types.Operator.Or:
          {
            return this.evaluateNode(node.left, data) || this.evaluateNode(node.right, data);
          }
        default:
          break;
      }
    }
    return false;
  }
  isLeafNode(node) {
    return !Boolean(node.left && node.right);
  }
  isNonLeafNode(node) {
    return Boolean(node.left && node.right && (node.value === _types.Operator.Or || node.value === _types.Operator.And));
  }
  flattenSegment(segment) {
    const {
      firstLevel: conditions,
      firstLevelOrOperators: operators
    } = segment.conditionsData;
    const resultOperators = [...operators];
    const resultConditions = [];
    conditions.forEach(condition => {
      const {
        conditions: conditionList,
        orOperators
      } = condition;

      // --- Note ---
      // if `condition` has nested conditions and operators in it, they go to the
      // beginning of list, otherwise we just add it to the end
      if (orOperators.length) {
        orOperators.forEach(item => resultOperators.unshift(item));
        conditionList.forEach(item => resultConditions.unshift(item));
      } else {
        conditionList.forEach(item => resultConditions.push(item));
      }
    });
    const convertedOperators = resultOperators.map(operator => operator ? _types.Operator.Or : _types.Operator.And);
    return {
      conditions: resultConditions,
      operators: convertedOperators
    };
  }
}
exports.TargetingTree = TargetingTree;
//# sourceMappingURL=targetingTree.js.map