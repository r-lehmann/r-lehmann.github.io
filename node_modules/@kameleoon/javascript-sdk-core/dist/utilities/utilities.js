"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Utilities = void 0;
var _tsRes = require("ts-res");
var _kameleoonError = require("../kameleoonError");
var _types = require("../types");
var _targeting = require("../targeting");
var _constants = require("./constants");
var _kameleoonData = require("../kameleoonData");
var _constants2 = require("../constants");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class Utilities {
  static checkTargeting({
    segment,
    visitorCode,
    targetingData,
    experimentId,
    variationConfiguration
  }) {
    if (!segment || !segment.conditionsData.firstLevel.length) {
      return (0, _tsRes.Ok)(true);
    }
    if (!variationConfiguration) {
      return (0, _tsRes.Err)(new _kameleoonError.KameleoonError(_kameleoonError.KameleoonException.Initialization));
    }
    let variations = {};
    const assignedVariationsResult = variationConfiguration.getAssignedVariations(visitorCode);
    if (assignedVariationsResult.ok) {
      variations = assignedVariationsResult.data;
    }
    const targetingTree = new _targeting.TargetingTree(segment);
    const result = targetingTree.evaluate({
      targetingData: targetingData || [],
      variationData: variations,
      experimentId
    });
    return result;
  }
  static validateVisitorCode(visitorCode) {
    if (visitorCode.length > _constants.VISITOR_CODE_MAX_LENGTH) {
      return (0, _tsRes.Err)(new _kameleoonError.KameleoonError(_kameleoonError.KameleoonException.VisitorCodeMaxLength));
    }
    return (0, _tsRes.Ok)();
  }
  static getDataUrl(visitorCode, campaignConfiguration) {
    const unsentData = campaignConfiguration.getUnsentData(visitorCode);
    return unsentData.map(item => item.url).join('\n');
  }
  static trackRule({
    featureFlagVariation,
    campaignConfiguration,
    visitorCode,
    requester,
    userAgent
  }) {
    const {
      variationId,
      rule
    } = featureFlagVariation;
    if (!rule) {
      throw new Error('Internal usage error, make sure to use `trackRule` for existing rule');
    }
    const dataUrl = this.getDataUrl(visitorCode, campaignConfiguration);
    const resultVariationId = variationId || 0;
    const isUnallocated = variationId === null;
    const callback = () => campaignConfiguration.clearUnsentData;
    requester.trackExperiment({
      visitorCode,
      isUnallocated,
      body: dataUrl,
      callback,
      experimentId: rule.experimentId,
      variationId: resultVariationId,
      userAgent
    });
  }
  static parseFeatureVariable(variable) {
    const {
      type,
      value
    } = variable;
    switch (type) {
      case _types.VariableType.BOOLEAN:
        return (0, _tsRes.Ok)({
          type,
          value: Boolean(value)
        });
      case _types.VariableType.STRING:
        return (0, _tsRes.Ok)({
          type,
          value: String(value)
        });
      case _types.VariableType.NUMBER:
        const numberValue = Number(value);
        if (Number.isNaN(numberValue)) {
          return (0, _tsRes.Err)(new _kameleoonError.KameleoonError(_kameleoonError.KameleoonException.NumberParse, String(value)));
        }
        return (0, _tsRes.Ok)({
          type,
          value: numberValue
        });
      case _types.VariableType.JSON:
        try {
          const jsonValue = JSON.parse(String(variable.value));
          return (0, _tsRes.Ok)({
            type,
            value: jsonValue
          });
        } catch (err) {
          return (0, _tsRes.Err)(new _kameleoonError.KameleoonError(_kameleoonError.KameleoonException.JSONParse, err));
        }
      default:
        (0, _kameleoonError.exhaustCheck)(type);
    }
  }
  static getUserAgent(visitorCode, campaignConfiguration) {
    const isUserAgent = data => data.type === _kameleoonData.KameleoonData.UserAgent;
    const targetingData = campaignConfiguration.storedTargetingData[visitorCode];
    if (targetingData) {
      const filteredData = targetingData.map(item => item.data).filter(isUserAgent);
      if (filteredData.length) {
        const [userAgentData] = filteredData;
        return userAgentData.value;
      }
    }
    return undefined;
  }
  static updateCache({
    cacheManager,
    visitorCode,
    experimentId,
    variationId
  }) {
    const cacheData = cacheManager.getAliveItem(visitorCode);
    const newCacheData = cacheData ? _objectSpread({}, cacheData) : {};
    newCacheData[experimentId] = {
      variationId,
      expirationTime: Date.now() + _constants2.CACHE_ITEM_LIFETIME * _types.Milliseconds.Second
    };
    cacheManager.add({
      key: visitorCode,
      data: newCacheData,
      lifetime: _constants2.CACHE_ITEM_LIFETIME
    });
  }
  static getTrackingCode(trackingCache, visitorCode) {
    let resultString = 'window.kameleoonQueue=window.kameleoonQueue||[];';
    const cacheData = trackingCache.getAliveItem(visitorCode);
    if (!cacheData) {
      return resultString;
    }
    const updatedCacheData = {};
    Object.entries(cacheData).forEach(([experimentId, {
      variationId,
      expirationTime
    }]) => {
      if (expirationTime > Date.now()) {
        resultString += `window.kameleoonQueue.push(['Experiments.assignVariation',${experimentId},${variationId}]);`;
        resultString += `window.kameleoonQueue.push(['Experiments.trigger',${experimentId},true]);`;
        updatedCacheData[Number(experimentId)] = {
          variationId,
          expirationTime
        };
      }
    });

    // --- Note ---
    // Cache is updated with only alive experiments
    trackingCache.add({
      key: visitorCode,
      data: updatedCacheData,
      lifetime: _constants2.CACHE_ITEM_LIFETIME
    });
    return resultString;
  }
}
exports.Utilities = Utilities;
//# sourceMappingURL=utilities.js.map