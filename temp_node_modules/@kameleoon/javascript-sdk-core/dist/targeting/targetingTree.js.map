{"version":3,"file":"targetingTree.js","names":["_tsRes","require","_targetingNode","_types","_defineProperty","obj","key","value","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","arg","_toPrimitive","String","input","hint","prim","Symbol","toPrimitive","undefined","res","call","TypeError","Number","TargetingTree","constructor","segment","conditions","operators","flattenSegment","nodes","map","condition","TargetingNode","operator","left","shift","right","unshift","tree","evaluate","data","result","evaluateNode","error","Err","Ok","node","isLeafNode","ok","isNonLeafNode","Operator","And","Or","Boolean","firstLevel","firstLevelOrOperators","conditionsData","resultOperators","resultConditions","forEach","conditionList","orOperators","length","item","push","convertedOperators","exports"],"sources":["../../src/targeting/targetingTree.ts"],"sourcesContent":["import { Result, Ok, Err } from 'ts-res';\nimport { KameleoonError } from '../kameleoonError';\nimport { ConditionDataType } from './conditions';\nimport { ITargetingNode, TargetingNode } from './targetingNode';\nimport {\n  EvaluationDataType,\n  FlatSegmentType,\n  LeafNodeType,\n  NonLeafNodeType,\n  Operator,\n  SegmentType,\n} from './types';\n\ninterface ITargetingTree {\n  evaluate: (data: EvaluationDataType) => Result<boolean, KameleoonError>;\n}\n\nexport class TargetingTree implements ITargetingTree {\n  private tree: TargetingNode;\n  private error: KameleoonError | null = null;\n\n  constructor(segment: SegmentType) {\n    const { conditions, operators } = this.flattenSegment(segment);\n    const nodes = conditions.map((condition) => new TargetingNode(condition));\n\n    // --- Note ---\n    // - Targeting tree is built bottom-up, it's the only way to both get the consistent logic\n    // (grouping nested conditions) and have human readable tree representation.\n    // - Here is an example of how tree is built (we use strict complete binary tree)\n    // Let's say we have such a condition `value < 10 || value > 20 && value < 30`\n    // Code-wise it looks as follows (this is not real code, real tree is more complicated and can have more\n    // levels of deeply nested conditions):\n    //\n    // `const operators = [Operator.Or, Operator.And]`\n    // `const conditions = [\n    //     {type: Condition.Less, value: 10},\n    //     {type: Condition.Greater, value: 20},\n    //     {type: Condition.Less, value: 30},\n    // ]`\n    //\n    // After the first iteration we have node like this:\n    //    AND\n    //   /   \\\n    //  <30  >20\n    //\n    // After the second iteration tree looks as follows:\n    //         OR\n    //        /  \\\n    //    AND    <10\n    //   /   \\\n    //  <30  >20\n    // As you can see Leaf Nodes contain conditions and Non-Leaf Nodes contain logical operators\n    for (const operator of operators) {\n      const left = nodes.shift();\n      const right = nodes.shift();\n\n      nodes.unshift(new TargetingNode(operator, left, right));\n    }\n\n    // --- Note ---\n    // It's guaranteed that only one root node will remain after iterations\n    // (as soon as the backend `operators-conditions` relation doesn't change)\n    this.tree = nodes[0];\n  }\n\n  public evaluate(data: EvaluationDataType): Result<boolean, KameleoonError> {\n    const result = this.evaluateNode(this.tree, data);\n\n    if (this.error) {\n      return Err(this.error);\n    }\n\n    return Ok(result);\n  }\n\n  private evaluateNode(node: TargetingNode, data: EvaluationDataType): boolean {\n    if (this.isLeafNode(node)) {\n      if (node.error) {\n        // --- Note ---\n        // Non-existing condition should not break targeting tree\n        // instead it should be treated as `false` condition\n        return false;\n      }\n\n      const result = node.value.evaluate(data);\n\n      if (!result.ok) {\n        this.error = result.error;\n\n        return false;\n      }\n\n      return result.data;\n    }\n\n    if (this.isNonLeafNode(node)) {\n      switch (node.value) {\n        case Operator.And: {\n          return (\n            this.evaluateNode(node.left, data) &&\n            this.evaluateNode(node.right, data)\n          );\n        }\n        case Operator.Or: {\n          return (\n            this.evaluateNode(node.left, data) ||\n            this.evaluateNode(node.right, data)\n          );\n        }\n        default:\n          break;\n      }\n    }\n\n    return false;\n  }\n\n  private isLeafNode(node: ITargetingNode): node is LeafNodeType {\n    return !Boolean(node.left && node.right);\n  }\n\n  private isNonLeafNode(node: ITargetingNode): node is NonLeafNodeType {\n    return Boolean(\n      node.left &&\n        node.right &&\n        (node.value === Operator.Or || node.value === Operator.And),\n    );\n  }\n\n  private flattenSegment(segment: SegmentType): FlatSegmentType {\n    const { firstLevel: conditions, firstLevelOrOperators: operators } =\n      segment.conditionsData;\n\n    const resultOperators: boolean[] = [...operators];\n    const resultConditions: ConditionDataType[] = [];\n\n    conditions.forEach((condition) => {\n      const { conditions: conditionList, orOperators } = condition;\n\n      // --- Note ---\n      // if `condition` has nested conditions and operators in it, they go to the\n      // beginning of list, otherwise we just add it to the end\n      if (orOperators.length) {\n        orOperators.forEach((item) => resultOperators.unshift(item));\n        conditionList.forEach((item) => resultConditions.unshift(item));\n      } else {\n        conditionList.forEach((item) => resultConditions.push(item));\n      }\n    });\n\n    const convertedOperators = resultOperators.map((operator) =>\n      operator ? Operator.Or : Operator.And,\n    );\n\n    return { conditions: resultConditions, operators: convertedOperators };\n  }\n}\n"],"mappings":"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"}