"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VariationConfiguration = void 0;
var _tsRes = require("ts-res");
var _hasher = require("../hasher");
var _variation = require("./variation");
var _kameleoonError = require("../kameleoonError");
var _utilities = require("../utilities");
var _types = require("../campaignConfiguration/types");
const _excluded = ["exposition"];
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class VariationConfiguration {
  constructor(experiments, externalStorage) {
    _defineProperty(this, "experiments", void 0);
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "getAssociatedVariationId", (visitorCode, experimentId) => {
      let associatedVariation;
      this.storage.read().and(data => {
        associatedVariation = data?.[visitorCode]?.[experimentId];
      });
      const experiment = this.experiments.find(experiment => experiment.id === String(experimentId));
      if (!experiment) {
        return (0, _tsRes.Err)(new _kameleoonError.KameleoonError(_kameleoonError.KameleoonException.ExperimentConfigurationNotFound, experimentId, visitorCode));
      }
      const variation = new _variation.Variation(associatedVariation);
      if (variation.isValid(experiment?.respoolTime)) {
        return (0, _tsRes.Ok)(variation.id);
      }
      return this.assignVariation(visitorCode, experiment);
    });
    this.experiments = experiments;
    this.storage = externalStorage;
  }
  getAssignedVariations(visitorCode) {
    const result = this.storage.read();
    if (!result.ok) {
      return result;
    }
    const experiments = result.data[visitorCode];
    if (!experiments) {
      return (0, _tsRes.Err)(new _kameleoonError.KameleoonError(_kameleoonError.KameleoonException.StorageRead, visitorCode));
    }
    return (0, _tsRes.Ok)(experiments);
  }
  getFeatureFlagVariation({
    visitorCode,
    featureFlag,
    targetingData,
    withAssignment = false
  }) {
    const validateResult = _utilities.Utilities.validateVisitorCode(visitorCode);
    if (!validateResult.ok) {
      return (0, _tsRes.Err)(validateResult.error);
    }
    const {
      rules,
      featureKey,
      id: featureFlagId,
      defaultVariationKey
    } = featureFlag;
    for (const rule of rules) {
      const {
        segment,
        experimentId,
        id,
        exposition,
        respoolTime,
        variationByExposition
      } = rule;

      // --- Check targeting ---
      const targetingResult = _utilities.Utilities.checkTargeting({
        segment,
        visitorCode,
        experimentId,
        targetingData,
        variationConfiguration: this
      });
      if (!targetingResult.ok) {
        return targetingResult;
      }
      if (!targetingResult.data) {
        continue;
      }

      // --- Note ---
      // Calculate new variation (and assign it if `withAssignment` is `true`)
      // First the the exposed rule is calculated and then the variation inside of it
      const ruleHash = _hasher.Hasher.obtainFeatureFlagHashDouble({
        visitorCode,
        respoolTime,
        campaignId: String(id)
      });
      if (ruleHash <= exposition) {
        let totalDeviation = 0;
        const variationHash = _hasher.Hasher.obtainFeatureFlagHashDouble({
          visitorCode,
          respoolTime,
          campaignId: String(experimentId)
        });
        for (const variation of variationByExposition) {
          totalDeviation += variation.exposition;
          if (variationHash <= totalDeviation) {
            // --- Note ---
            // For the `RuleType.EXPERIMENTATION` variation assignment must happen without
            // calculating experiment deviation
            if (rule.type === _types.RuleType.EXPERIMENTATION && withAssignment) {
              this.updateStorageData({
                visitorCode,
                experimentId: String(experimentId),
                // --- Note ---
                // For `RuleType.EXPERIMENTATION` `variationId` can not be null
                variationId: variation.variationId
              });
            }
            const {
                exposition
              } = variation,
              restParameters = _objectWithoutProperties(variation, _excluded);
            return (0, _tsRes.Ok)(_objectSpread(_objectSpread({}, restParameters), {}, {
              rule,
              featureFlagId,
              featureKey,
              experimentId
            }));
          }
        }
      }
      if (rule.type === _types.RuleType.TARGETED_DELIVERY) {
        break;
      }
    }
    return (0, _tsRes.Ok)({
      featureKey,
      featureFlagId,
      experimentId: null,
      variationKey: defaultVariationKey,
      variationId: null,
      rule: null
    });
  }
  getExperimentVariation(visitorCode, experiment) {
    const {
      id,
      respoolTime,
      deviations
    } = experiment;
    const hashDouble = _hasher.Hasher.obtainExperimentHashDouble({
      visitorCode,
      campaignId: id,
      respoolTime
    });
    let isUnallocated = true;
    let totalDeviation = 0;
    let resultVariationId = 0;
    for (const deviation of deviations) {
      totalDeviation += deviation.value;
      if (totalDeviation >= hashDouble) {
        // --- Note ---
        // If sum of all variations is less than 1 (100%), then there is a chance
        // user will end up outside of any variation
        isUnallocated = false;
        // --- Note ---
        // 'origin' is the default `variationId`, it must return id of 0
        if (deviation.variationId !== 'origin') {
          resultVariationId = Number(deviation.variationId);
        }
        break;
      }
    }
    if (isUnallocated) {
      return (0, _tsRes.Err)(new _kameleoonError.KameleoonError(_kameleoonError.KameleoonException.NotAllocated, visitorCode));
    }
    return (0, _tsRes.Ok)(resultVariationId);
  }
  assignVariation(visitorCode, experiment) {
    const variationResult = this.getExperimentVariation(visitorCode, experiment);
    if (!variationResult.ok) {
      return variationResult;
    }
    const result = this.updateStorageData({
      visitorCode,
      experimentId: experiment.id,
      variationId: variationResult.data
    });
    if (!result.ok) {
      return result;
    }
    return (0, _tsRes.Ok)(variationResult.data);
  }
  updateStorageData({
    visitorCode,
    experimentId,
    variationId
  }) {
    const result = this.storage.read();
    if (!result.ok) {
      // --- Note ---
      // If there is a parsing error we return error
      // But if there is `LocalStorageRead` error it means that
      // data was read successfully and it's empty, which is not problem
      // cause that might be initial `read`
      if (result.error.type === _kameleoonError.KameleoonException.StorageParse) {
        return result;
      }
    }
    const updatedVariationData = result.ok ? result.data : {};
    const updatedVariation = {
      variationId,
      assignmentDate: new Date().toString()
    };
    if (updatedVariationData[visitorCode]) {
      updatedVariationData[visitorCode][experimentId] = updatedVariation;
    } else {
      updatedVariationData[visitorCode] = {
        [experimentId]: updatedVariation
      };
    }
    return this.storage.write(updatedVariationData);
  }

  // --- TODO: commented out in case of future logic rework ---
  // --- Mind: `variationId` could cause the `undefined` issue ---
  // --- Reference: https://development.kameleoon.net/sdk/javascript-sdk-packages/-/merge_requests/89 ---
  // private getAssignedRuleVariation(
  //   visitorCode: string,
  //   rule: RuleItemType,
  // ): Result<GetAssignedRuleVariationResultType, KameleoonError> {
  //   const emptyVariation: Omit<VariationByExpositionType, 'exposition'> = {
  //     variationId: null,
  //     variationKey: '',
  //   };
  //   const { experimentId, variationByExposition } = rule;

  //   const variationsResult = this.getAssignedVariations(visitorCode);

  //   // --- Note ---
  //   // If there is an error, we just want to skip seeking
  //   // for variation in the storage, not throw an error
  //   if (!variationsResult.ok) {
  //     return Ok(emptyVariation);
  //   }

  //   const variations = variationsResult.data;

  //   if (
  //     experimentId &&
  //     typeof variations[experimentId].variationId !== undefined
  //   ) {
  //     const id = variations[experimentId].variationId;
  //     const featureFlagVariation = variationByExposition.find(
  //       (item) => item.variationId == id,
  //     );

  //     if (!featureFlagVariation) {
  //       // --- Note ---
  //       // This error is not described for public methods as
  //       // it serves internal purpose of checking whether
  //       // the persistent variation has been updated and should be re-allocated
  //       return Err(new KameleoonError(KameleoonException.DataInconsistency));
  //     }

  //     const { exposition, ...restParameters } = featureFlagVariation;

  //     return Ok({ ...restParameters });
  //   }

  //   return Ok(emptyVariation);
  // }
}
exports.VariationConfiguration = VariationConfiguration;
//# sourceMappingURL=variationConfiguration.js.map